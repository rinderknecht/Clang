(* Preprocessor for C# 1.2 with Ulex. See driver module [Topproc]. *)

(* Positions *)

let lex_curr_p : Lexing.position ref =
  ref Lexing.{ pos_fname = ""; pos_lnum = 1; pos_cnum = 0; pos_bol = 0 }

(* [update buffer] not to be called on a new line *)

let update buffer : unit =
  lex_curr_p :=
    Lexing.{ !lex_curr_p with
      pos_cnum = !lex_curr_p.pos_cnum + Ulexing.lexeme_length buffer }

(* Virtual line number (according to #line) and end of lines *)

let virt_lnum = ref 1

let handle_nl buffer =
  let nl = Ulexing.utf8_lexeme buffer
in begin
     incr virt_lnum;
     lex_curr_p := Lexing.{ !lex_curr_p with
       pos_lnum = !lex_curr_p.pos_lnum + 1;
       pos_cnum = !lex_curr_p.pos_cnum + String.length nl;
       pos_bol  = !lex_curr_p.pos_cnum + 1 }
   end

(* Copying the current lexeme to [stdout] *)

let copy buffer = print_string (Ulexing.utf8_lexeme buffer)

(* String processing *)

let mk_str (len:int) (p:char list) : string =
  let s = Bytes.make len ' ' in 
  let rec fill i =
    function [] -> s | c::l -> Bytes.set s i c; fill (i-1) l
in assert (len = List.length p); Bytes.to_string (fill (len-1) p)

(* Error handling *)

let stop msg seg = raise (Error.Lexer (msg, seg))

let fail msg buffer =
  let lexeme_start_p = !lex_curr_p
in update buffer;
   raise (Error.(Lexer (msg, (lexeme_start_p, !lex_curr_p), !virt_lnum)))

exception Local_err of Error.message

let handle_err scan buffer =
  try scan buffer with Local_err msg -> fail msg buffer

(* Scanning modes *)

type mode = Copy | Skip

(* Trace of conditionals *)

type cond = If of mode | Elif of mode | Else | Region
type trace = cond list

let rec reduce_cond seg = function
              [] -> stop "Dangling #endif." seg
| If mode::trace -> trace, mode
|  Region::trace -> stop "Invalid scoping of #region" seg
|       _::trace -> reduce_cond seg trace

let reduce_reg seg = function
             [] -> stop "Dangling #endregion." seg
| Region::trace -> trace
|             _ -> stop "Invalid scoping of #endregion" seg

let extend seg cond trace =
  match cond, trace with
    If _, Elif _::_ ->
      stop "Directive #if cannot follow #elif." seg
  | Else,   Else::_ ->
      stop "Directive #else cannot follow #else." seg
  | Else,        [] ->
      stop "Dangling #else." seg
  | Elif _, Else::_ ->
      stop "Directive #elif cannot follow #else." seg
  | Elif _,      [] ->
      stop "Dangling #elif." seg
  |               _ -> cond::trace

let rec last_mode = function
                        [] -> assert false
| (If mode | Elif mode)::_ -> mode
|                 _::trace -> last_mode trace

(* Line offsets *)

type offset = Prefix of int | Inline

let expand = function Prefix 0 | Inline -> ()
                    | Prefix n -> print_string (String.make n ' ')

(* Directives *)

let directives = ["if"; "else"; "elif"; "endif"; "define"; "undef";
                  "error"; "warning"; "line"; "region"; "endregion"]

(* Environments and preprocessor expressions *)

module Env = Set.Make(String)

let rec eval env =
  let open Etree
in function
   Or (e1,e2) -> eval env e1 || eval env e2
| And (e1,e2) -> eval env e1 && eval env e2
|  Eq (e1,e2) -> eval env e1 = eval env e2
| Neq (e1,e2) -> eval env e1 != eval env e2
|       Not e -> not (eval env e)
|        True -> true
|       False -> false
|    Ident id -> Env.mem id env

let expr env buffer =
  let tree = Eparser.pp_expression Escan.token buffer
in if eval env tree then Copy else Skip

(* Regular expressions for literals *)

(* White space *)

let regexp newline =
  '\n'    (* Line feed           *)
| '\r'    (* Carriage return     *)
| "\r\n"  (* Specific to Windows *)
| 0x0085  (* Next line           *)
| 0x2028  (* Line separator      *)
| 0x2029  (* Paragraph separator *)

let regexp zs =
  0x20 | 0xa0 | 0x1680 | [0x2000-0x200a] | 0x202f | 0x205f | 0x3000

let regexp blank =
  zs
| '\t'   (* Tabulation          *)
| '\009' (* Vertical tabulation *)
| '\012' (* Form feed           *)

(* Integer literals *)

let regexp integer_type_suffix =
  ['U' 'u' 'L' 'l']
| "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"
let regexp decimal_digit = [0-9]
let regexp decimal_integer = decimal_digit+ integer_type_suffix?
let regexp hex_digit = decimal_digit | ['A'-'F' 'a'-'f']
let regexp hex_pre = "0x" | "0X"
let regexp hexa_integer = hex_pre hex_digit+ integer_type_suffix?
let regexp integer = decimal_integer | hexa_integer

(* Number, Decimal Digit *)

let regexp nd = 
  [0x30-0x39] | [0x660-0x669] | [0x6f0-0x6f9] | [0x7c0-0x7c9]
| [0x966-0x96f] | [0x9e6-0x9ef] | [0xa66-0xa6f] | [0xae6-0xaef]
| [0xb66-0xb6f] | [0xbe6-0xbef] | [0xc66-0xc6f] | [0xce6-0xcef]
| [0xd66-0xd6f] | [0xde6-0xdef] | [0xe50-0xe59] | [0xed0-0xed9]
| [0xf20-0xf29] | [0x1040-0x1049] | [0x1090-0x1099]
| [0x17e0-0x17e9] | [0x1810-0x1819] | [0x1946-0x194f]
| [0x19d0-0x19d9] | [0x1a80-0x1a89] | [0x1a90-0x1a99]
| [0x1b50-0x1b59] | [0x1bb0-0x1bb9] | [0x1c40-0x1c49]
| [0x1c50-0x1c59] | [0xa620-0xa629] | [0xa8d0-0xa8d9]
| [0xa900-0xa909] | [0xa9d0-0xa9d9] | [0xa9f0-0xa9f9]
| [0xaa50-0xaa59] | [0xabf0-0xabf9] | [0xff10-0xff19]
| [0x104a0-0x104a9] | [0x11066-0x1106f] | [0x110f0-0x110f9]
| [0x11136-0x1113f] | [0x111d0-0x111d9] | [0x112f0-0x112f9]
| [0x114d0-0x114d9] | [0x11650-0x11659] | [0x116c0-0x116c9]
| [0x118e0-0x118e9] | [0x16a60-0x16a69] | [0x16b50-0x16b59]
| [0x1d7ce-0x1d7ff]

(* Letter, Uppercase *)

let regexp lu =
  [0x41-0x5a] | [0xc0-0xd6] | [0xd8-0xde] | 0x100 | 0x102 | 0x104
| 0x106 | 0x108 | 0x10a | 0x10c | 0x10e | 0x110 | 0x112 | 0x114
| 0x116 | 0x118 | 0x11a | 0x11c | 0x11e | 0x120 | 0x122 | 0x124
| 0x126 | 0x128 | 0x12a | 0x12c | 0x12e | 0x130 | 0x132 | 0x134
| 0x136 | 0x139 | 0x13b | 0x13d | 0x13f | 0x141 | 0x143 | 0x145
| 0x147 | 0x14a | 0x14c | 0x14e | 0x150 | 0x152 | 0x154 | 0x156
| 0x158 | 0x15a | 0x15c | 0x15e | 0x160 | 0x162 | 0x164 | 0x166
| 0x168 | 0x16a | 0x16c | 0x16e | 0x170 | 0x172 | 0x174 | 0x176
| [0x178-0x179] | 0x17b | 0x17d | [0x181-0x182] | 0x184 
| [0x186-0x187] | [0x189-0x18b] | [0x18e-0x191] | [0x193-0x194]
| [0x196-0x198] | [0x19c-0x19d] | [0x19f-0x1a0] | 0x1a2 | 0x1a4
| [0x1a6-0x1a7] | 0x1a9 | 0x1ac | [0x1ae-0x1af] | [0x1b1-0x1b3]
| 0x1b5 | [0x1b7-0x1b8] | 0x1bc | 0x1c4 | 0x1c7 | 0x1ca | 0x1cd
| 0x1cf | 0x1d1 | 0x1d3 | 0x1d5 | 0x1d7 | 0x1d9 | 0x1db | 0x1de
| 0x1e0 | 0x1e2 | 0x1e4 | 0x1e6 | 0x1e8 | 0x1ea | 0x1ec | 0x1ee
| 0x1f1 | 0x1f4 | [0x1f6-0x1f8] | 0x1fa | 0x1fc | 0x1fe | 0x200
| 0x202 | 0x204 | 0x206 | 0x208 | 0x20a | 0x20c | 0x20e | 0x210
| 0x212 | 0x214 | 0x216 | 0x218 | 0x21a | 0x21c | 0x21e | 0x220
| 0x222 | 0x224 | 0x226 | 0x228 | 0x22a | 0x22c | 0x22e | 0x230
| 0x232 | [0x23a-0x23b] | [0x23d-0x23e] | 0x241 | [0x243-0x246]
| 0x248 | 0x24a | 0x24c | 0x24e | 0x370 | 0x372 | 0x376 | 0x37f
| 0x386 | [0x388-0x38a] | 0x38c | [0x38e-0x38f] | [0x391-0x3a1]
| [0x3a3-0x3ab] | 0x3cf | [0x3d2-0x3d4] | 0x3d8 | 0x3da | 0x3dc
| 0x3de | 0x3e0 | 0x3e2 | 0x3e4 | 0x3e6 | 0x3e8 | 0x3ea | 0x3ec
| 0x3ee | 0x3f4 | 0x3f7 | [0x3f9-0x3fa] | [0x3fd-0x42f] | 0x460
| 0x462 | 0x464 | 0x466 | 0x468 | 0x46a | 0x46c | 0x46e | 0x470
| 0x472 | 0x474 | 0x476 | 0x478 | 0x47a | 0x47c | 0x47e | 0x480
| 0x48a | 0x48c | 0x48e | 0x490 | 0x492 | 0x494 | 0x496 | 0x498
| 0x49a | 0x49c | 0x49e | 0x4a0 | 0x4a2 | 0x4a4 | 0x4a6 | 0x4a8
| 0x4aa | 0x4ac | 0x4ae | 0x4b0 | 0x4b2 | 0x4b4 | 0x4b6 | 0x4b8
| 0x4ba | 0x4bc | 0x4be | [0x4c0-0x4c1] | 0x4c3 | 0x4c5 | 0x4c7
| 0x4c9 | 0x4cb | 0x4cd | 0x4d0 | 0x4d2 | 0x4d4 | 0x4d6 | 0x4d8
| 0x4da | 0x4dc | 0x4de | 0x4e0 | 0x4e2 | 0x4e4 | 0x4e6 | 0x4e8
| 0x4ea | 0x4ec | 0x4ee | 0x4f0 | 0x4f2 | 0x4f4 | 0x4f6 | 0x4f8
| 0x4fa | 0x4fc | 0x4fe | 0x500 | 0x502 | 0x504 | 0x506 | 0x508
| 0x50a | 0x50c | 0x50e | 0x510 | 0x512 | 0x514 | 0x516 | 0x518
| 0x51a | 0x51c | 0x51e | 0x520 | 0x522 | 0x524 | 0x526 | 0x528
| 0x52a | 0x52c | 0x52e | [0x531-0x556] | [0x10a0-0x10c5] | 0x10c7
| 0x10cd | 0x1e00 | 0x1e02 | 0x1e04 | 0x1e06 | 0x1e08 | 0x1e0a
| 0x1e0c | 0x1e0e | 0x1e10 | 0x1e12 | 0x1e14 | 0x1e16 | 0x1e18
| 0x1e1a | 0x1e1c | 0x1e1e | 0x1e20 | 0x1e22 | 0x1e24 | 0x1e26
| 0x1e28 | 0x1e2a | 0x1e2c | 0x1e2e | 0x1e30 | 0x1e32 | 0x1e34
| 0x1e36 | 0x1e38 | 0x1e3a | 0x1e3c | 0x1e3e | 0x1e40 | 0x1e42
| 0x1e44 | 0x1e46 | 0x1e48 | 0x1e4a | 0x1e4c | 0x1e4e | 0x1e50
| 0x1e52 | 0x1e54 | 0x1e56 | 0x1e58 | 0x1e5a | 0x1e5c | 0x1e5e
| 0x1e60 | 0x1e62 | 0x1e64 | 0x1e66 | 0x1e68 | 0x1e6a | 0x1e6c
| 0x1e6e | 0x1e70 | 0x1e72 | 0x1e74 | 0x1e76 | 0x1e78 | 0x1e7a
| 0x1e7c | 0x1e7e | 0x1e80 | 0x1e82 | 0x1e84 | 0x1e86 | 0x1e88
| 0x1e8a | 0x1e8c | 0x1e8e | 0x1e90 | 0x1e92 | 0x1e94 | 0x1e9e
| 0x1ea0 | 0x1ea2 | 0x1ea4 | 0x1ea6 | 0x1ea8 | 0x1eaa | 0x1eac
| 0x1eae | 0x1eb0 | 0x1eb2 | 0x1eb4 | 0x1eb6 | 0x1eb8 | 0x1eba
| 0x1ebc | 0x1ebe | 0x1ec0 | 0x1ec2 | 0x1ec4 | 0x1ec6 | 0x1ec8
| 0x1eca | 0x1ecc | 0x1ece | 0x1ed0 | 0x1ed2 | 0x1ed4 | 0x1ed6
| 0x1ed8 | 0x1eda | 0x1edc | 0x1ede | 0x1ee0 | 0x1ee2 | 0x1ee4
| 0x1ee6 | 0x1ee8 | 0x1eea | 0x1eec | 0x1eee | 0x1ef0 | 0x1ef2
| 0x1ef4 | 0x1ef6 | 0x1ef8 | 0x1efa | 0x1efc | 0x1efe
| [0x1f08-0x1f0f] | [0x1f18-0x1f1d] | [0x1f28-0x1f2f]
| [0x1f38-0x1f3f] | [0x1f48-0x1f4d] | 0x1f59 | 0x1f5b | 0x1f5d
| 0x1f5f | [0x1f68-0x1f6f] | [0x1fb8-0x1fbb] | [0x1fc8-0x1fcb]
| [0x1fd8-0x1fdb] | [0x1fe8-0x1fec] | [0x1ff8-0x1ffb] | 0x2102
| 0x2107 | [0x210b-0x210d] | [0x2110-0x2112] | 0x2115
| [0x2119-0x211d] | 0x2124 | 0x2126 | 0x2128 | [0x212a-0x212d]
| [0x2130-0x2133] | [0x213e-0x213f] | 0x2145 | 0x2183
| [0x2c00-0x2c2e] | 0x2c60 | [0x2c62-0x2c64] | 0x2c67 | 0x2c69
| 0x2c6b | [0x2c6d-0x2c70] | 0x2c72 | 0x2c75 | [0x2c7e-0x2c80]
| 0x2c82 | 0x2c84 | 0x2c86 | 0x2c88 | 0x2c8a | 0x2c8c | 0x2c8e
| 0x2c90 | 0x2c92 | 0x2c94 | 0x2c96 | 0x2c98 | 0x2c9a | 0x2c9c
| 0x2c9e | 0x2ca0 | 0x2ca2 | 0x2ca4 | 0x2ca6 | 0x2ca8 | 0x2caa
| 0x2cac | 0x2cae | 0x2cb0 | 0x2cb2 | 0x2cb4 | 0x2cb6 | 0x2cb8
| 0x2cba | 0x2cbc | 0x2cbe | 0x2cc0 | 0x2cc2 | 0x2cc4 | 0x2cc6
| 0x2cc8 | 0x2cca | 0x2ccc | 0x2cce | 0x2cd0 | 0x2cd2 | 0x2cd4
| 0x2cd6 | 0x2cd8 | 0x2cda | 0x2cdc | 0x2cde | 0x2ce0 | 0x2ce2
| 0x2ceb | 0x2ced | 0x2cf2 | 0xa640 | 0xa642 | 0xa644 | 0xa646
| 0xa648 | 0xa64a | 0xa64c | 0xa64e | 0xa650 | 0xa652 | 0xa654
| 0xa656 | 0xa658 | 0xa65a | 0xa65c | 0xa65e | 0xa660 | 0xa662
| 0xa664 | 0xa666 | 0xa668 | 0xa66a | 0xa66c | 0xa680 | 0xa682
| 0xa684 | 0xa686 | 0xa688 | 0xa68a | 0xa68c | 0xa68e | 0xa690
| 0xa692 | 0xa694 | 0xa696 | 0xa698 | 0xa69a | 0xa722 | 0xa724
| 0xa726 | 0xa728 | 0xa72a | 0xa72c | 0xa72e | 0xa732 | 0xa734
| 0xa736 | 0xa738 | 0xa73a | 0xa73c | 0xa73e | 0xa740 | 0xa742
| 0xa744 | 0xa746 | 0xa748 | 0xa74a | 0xa74c | 0xa74e | 0xa750
| 0xa752 | 0xa754 | 0xa756 | 0xa758 | 0xa75a | 0xa75c | 0xa75e
| 0xa760 | 0xa762 | 0xa764 | 0xa766 | 0xa768 | 0xa76a | 0xa76c
| 0xa76e | 0xa779 | 0xa77b | [0xa77d-0xa77e] | 0xa780 | 0xa782
| 0xa784 | 0xa786 | 0xa78b | 0xa78d | 0xa790 | 0xa792 | 0xa796
| 0xa798 | 0xa79a | 0xa79c | 0xa79e | 0xa7a0 | 0xa7a2 | 0xa7a4
| 0xa7a6 | 0xa7a8 | [0xa7aa-0xa7ad] | [0xa7b0-0xa7b1]
| [0xff21-0xff3a] | [0x10400-0x10427] | [0x118a0-0x118bf]
| [0x1d400-0x1d419] | [0x1d434-0x1d44d] | [0x1d468-0x1d481]
| 0x1d49c | [0x1d49e-0x1d49f] | 0x1d4a2 | [0x1d4a5-0x1d4a6]
| [0x1d4a9-0x1d4ac] | [0x1d4ae-0x1d4b5] | [0x1d4d0-0x1d4e9]
| [0x1d504-0x1d505] | [0x1d507-0x1d50a] | [0x1d50d-0x1d514]
| [0x1d516-0x1d51c] | [0x1d538-0x1d539] | [0x1d53b-0x1d53e]
| [0x1d540-0x1d544] | 0x1d546 | [0x1d54a-0x1d550]
| [0x1d56c-0x1d585] | [0x1d5a0-0x1d5b9] | [0x1d5d4-0x1d5ed]
| [0x1d608-0x1d621] | [0x1d63c-0x1d655] | [0x1d670-0x1d689]
| [0x1d6a8-0x1d6c0] | [0x1d6e2-0x1d6fa] | [0x1d71c-0x1d734]
| [0x1d756-0x1d76e] | [0x1d790-0x1d7a8] | 0x1d7ca

(* Letter, Lowercase *)

let regexp ll =
  [0x61-0x7a] | 0xb5 | [0xdf-0xf6] | [0xf8-0xff] | 0x101 | 0x103
| 0x105 | 0x107 | 0x109 | 0x10b | 0x10d | 0x10f | 0x111 | 0x113
| 0x115 | 0x117 | 0x119 | 0x11b | 0x11d | 0x11f | 0x121 | 0x123
| 0x125 | 0x127 | 0x129 | 0x12b | 0x12d | 0x12f | 0x131 | 0x133
| 0x135 | [0x137-0x138] | 0x13a | 0x13c | 0x13e | 0x140 | 0x142
| 0x144 | 0x146 | [0x148-0x149] | 0x14b | 0x14d | 0x14f | 0x151
| 0x153 | 0x155 | 0x157 | 0x159 | 0x15b | 0x15d | 0x15f | 0x161
| 0x163 | 0x165 | 0x167 | 0x169 | 0x16b | 0x16d | 0x16f | 0x171
| 0x173 | 0x175 | 0x177 | 0x17a | 0x17c | [0x17e-0x180] | 0x183
| 0x185 | 0x188 | [0x18c-0x18d] | 0x192 | 0x195 | [0x199-0x19b]
| 0x19e | 0x1a1 | 0x1a3 | 0x1a5 | 0x1a8 | [0x1aa-0x1ab] | 0x1ad
| 0x1b0 | 0x1b4 | 0x1b6 | [0x1b9-0x1ba] | [0x1bd-0x1bf] | 0x1c6
| 0x1c9 | 0x1cc | 0x1ce | 0x1d0 | 0x1d2 | 0x1d4 | 0x1d6 | 0x1d8
| 0x1da | [0x1dc-0x1dd] | 0x1df | 0x1e1 | 0x1e3 | 0x1e5 | 0x1e7
| 0x1e9 | 0x1eb | 0x1ed | [0x1ef-0x1f0] | 0x1f3 | 0x1f5 | 0x1f9
| 0x1fb | 0x1fd | 0x1ff | 0x201 | 0x203 | 0x205 | 0x207 | 0x209
| 0x20b | 0x20d | 0x20f | 0x211 | 0x213 | 0x215 | 0x217 | 0x219
| 0x21b | 0x21d | 0x21f | 0x221 | 0x223 | 0x225 | 0x227 | 0x229
| 0x22b | 0x22d | 0x22f | 0x231 | [0x233-0x239] | 0x23c
| [0x23f-0x240] | 0x242 | 0x247 | 0x249 | 0x24b | 0x24d
| [0x24f-0x293] | [0x295-0x2af] | 0x371 | 0x373 | 0x377
| [0x37b-0x37d] | 0x390 | [0x3ac-0x3ce] | [0x3d0-0x3d1]
| [0x3d5-0x3d7] | 0x3d9 | 0x3db | 0x3dd | 0x3df | 0x3e1 | 0x3e3
| 0x3e5 | 0x3e7 | 0x3e9 | 0x3eb | 0x3ed | [0x3ef-0x3f3] | 0x3f5
| 0x3f8 | [0x3fb-0x3fc] | [0x430-0x45f] | 0x461 | 0x463 | 0x465
| 0x467 | 0x469 | 0x46b | 0x46d | 0x46f | 0x471 | 0x473 | 0x475
| 0x477 | 0x479 | 0x47b | 0x47d | 0x47f | 0x481 | 0x48b | 0x48d
| 0x48f | 0x491 | 0x493 | 0x495 | 0x497 | 0x499 | 0x49b | 0x49d
| 0x49f | 0x4a1 | 0x4a3 | 0x4a5 | 0x4a7 | 0x4a9 | 0x4ab | 0x4ad
| 0x4af | 0x4b1 | 0x4b3 | 0x4b5 | 0x4b7 | 0x4b9 | 0x4bb | 0x4bd
| 0x4bf | 0x4c2 | 0x4c4 | 0x4c6 | 0x4c8 | 0x4ca | 0x4cc
| [0x4ce-0x4cf] | 0x4d1 | 0x4d3 | 0x4d5 | 0x4d7 | 0x4d9 | 0x4db
| 0x4dd | 0x4df | 0x4e1 | 0x4e3 | 0x4e5 | 0x4e7 | 0x4e9 | 0x4eb
| 0x4ed | 0x4ef | 0x4f1 | 0x4f3 | 0x4f5 | 0x4f7 | 0x4f9 | 0x4fb
| 0x4fd | 0x4ff | 0x501 | 0x503 | 0x505 | 0x507 | 0x509 | 0x50b
| 0x50d | 0x50f | 0x511 | 0x513 | 0x515 | 0x517 | 0x519 | 0x51b
| 0x51d | 0x51f | 0x521 | 0x523 | 0x525 | 0x527 | 0x529 | 0x52b
| 0x52d | 0x52f | [0x561-0x587] | [0x1d00-0x1d2b] | [0x1d6b-0x1d77]
| [0x1d79-0x1d9a] | 0x1e01 | 0x1e03 | 0x1e05 | 0x1e07 | 0x1e09
| 0x1e0b | 0x1e0d | 0x1e0f | 0x1e11 | 0x1e13 | 0x1e15 | 0x1e17
| 0x1e19 | 0x1e1b | 0x1e1d | 0x1e1f | 0x1e21 | 0x1e23 | 0x1e25
| 0x1e27 | 0x1e29 | 0x1e2b | 0x1e2d | 0x1e2f | 0x1e31 | 0x1e33
| 0x1e35 | 0x1e37 | 0x1e39 | 0x1e3b | 0x1e3d | 0x1e3f | 0x1e41
| 0x1e43 | 0x1e45 | 0x1e47 | 0x1e49 | 0x1e4b | 0x1e4d | 0x1e4f
| 0x1e51 | 0x1e53 | 0x1e55 | 0x1e57 | 0x1e59 | 0x1e5b | 0x1e5d
| 0x1e5f | 0x1e61 | 0x1e63 | 0x1e65 | 0x1e67 | 0x1e69 | 0x1e6b
| 0x1e6d | 0x1e6f | 0x1e71 | 0x1e73 | 0x1e75 | 0x1e77 | 0x1e79
| 0x1e7b | 0x1e7d | 0x1e7f | 0x1e81 | 0x1e83 | 0x1e85 | 0x1e87
| 0x1e89 | 0x1e8b | 0x1e8d | 0x1e8f | 0x1e91 | 0x1e93 
| [0x1e95-0x1e9d] | 0x1e9f | 0x1ea1 | 0x1ea3 | 0x1ea5 | 0x1ea7
| 0x1ea9 | 0x1eab | 0x1ead | 0x1eaf | 0x1eb1 | 0x1eb3 | 0x1eb5
| 0x1eb7 | 0x1eb9 | 0x1ebb | 0x1ebd | 0x1ebf | 0x1ec1 | 0x1ec3
| 0x1ec5 | 0x1ec7 | 0x1ec9 | 0x1ecb | 0x1ecd | 0x1ecf | 0x1ed1
| 0x1ed3 | 0x1ed5 | 0x1ed7 | 0x1ed9 | 0x1edb | 0x1edd | 0x1edf
| 0x1ee1 | 0x1ee3 | 0x1ee5 | 0x1ee7 | 0x1ee9 | 0x1eeb | 0x1eed
| 0x1eef | 0x1ef1 | 0x1ef3 | 0x1ef5 | 0x1ef7 | 0x1ef9 | 0x1efb
| 0x1efd | [0x1eff-0x1f07] | [0x1f10-0x1f15] | [0x1f20-0x1f27]
| [0x1f30-0x1f37] | [0x1f40-0x1f45] | [0x1f50-0x1f57]
| [0x1f60-0x1f67] | [0x1f70-0x1f7d] | [0x1f80-0x1f87]
| [0x1f90-0x1f97] | [0x1fa0-0x1fa7] | [0x1fb0-0x1fb4]
| [0x1fb6-0x1fb7] | 0x1fbe | [0x1fc2-0x1fc4] | [0x1fc6-0x1fc7]
| [0x1fd0-0x1fd3] | [0x1fd6-0x1fd7] | [0x1fe0-0x1fe7]
| [0x1ff2-0x1ff4] | [0x1ff6-0x1ff7] | 0x210a | [0x210e-0x210f]
| 0x2113 | 0x212f | 0x2134 | 0x2139 | [0x213c-0x213d]
| [0x2146-0x2149] | 0x214e | 0x2184 | [0x2c30-0x2c5e]
| 0x2c61 | [0x2c65-0x2c66] | 0x2c68 | 0x2c6a | 0x2c6c | 0x2c71
| [0x2c73-0x2c74] | [0x2c76-0x2c7b] | 0x2c81 | 0x2c83 | 0x2c85
| 0x2c87 | 0x2c89 | 0x2c8b | 0x2c8d | 0x2c8f | 0x2c91 | 0x2c93
| 0x2c95 | 0x2c97 | 0x2c99 | 0x2c9b | 0x2c9d | 0x2c9f | 0x2ca1
| 0x2ca3 | 0x2ca5 | 0x2ca7 | 0x2ca9 | 0x2cab | 0x2cad | 0x2caf
| 0x2cb1 | 0x2cb3 | 0x2cb5 | 0x2cb7 | 0x2cb9 | 0x2cbb | 0x2cbd
| 0x2cbf | 0x2cc1 | 0x2cc3 | 0x2cc5 | 0x2cc7 | 0x2cc9 | 0x2ccb
| 0x2ccd | 0x2ccf | 0x2cd1 | 0x2cd3 | 0x2cd5 | 0x2cd7 | 0x2cd9
| 0x2cdb | 0x2cdd | 0x2cdf | 0x2ce1 | [0x2ce3-0x2ce4] | 0x2cec
| 0x2cee | 0x2cf3 | [0x2d00-0x2d25] | 0x2d27 | 0x2d2d | 0xa641
| 0xa643 | 0xa645 | 0xa647 | 0xa649 | 0xa64b | 0xa64d | 0xa64f
| 0xa651 | 0xa653 | 0xa655 | 0xa657 | 0xa659 | 0xa65b | 0xa65d
| 0xa65f | 0xa661 | 0xa663 | 0xa665 | 0xa667 | 0xa669 | 0xa66b
| 0xa66d | 0xa681 | 0xa683 | 0xa685 | 0xa687 | 0xa689 | 0xa68b
| 0xa68d | 0xa68f | 0xa691 | 0xa693 | 0xa695 | 0xa697 | 0xa699
| 0xa69b | 0xa723 | 0xa725 | 0xa727 | 0xa729 | 0xa72b | 0xa72d
| [0xa72f-0xa731] | 0xa733 | 0xa735 | 0xa737 | 0xa739 | 0xa73b
| 0xa73d | 0xa73f | 0xa741 | 0xa743 | 0xa745 | 0xa747 | 0xa749
| 0xa74b | 0xa74d | 0xa74f | 0xa751 | 0xa753 | 0xa755 | 0xa757
| 0xa759 | 0xa75b | 0xa75d | 0xa75f | 0xa761 | 0xa763 | 0xa765
| 0xa767 | 0xa769 | 0xa76b | 0xa76d | 0xa76f | [0xa771-0xa778]
| 0xa77a | 0xa77c | 0xa77f | 0xa781 | 0xa783 | 0xa785 | 0xa787
| 0xa78c | 0xa78e | 0xa791 | [0xa793-0xa795] | 0xa797 | 0xa799
| 0xa79b | 0xa79d | 0xa79f | 0xa7a1 | 0xa7a3 | 0xa7a5 | 0xa7a7
| 0xa7a9 | 0xa7fa | [0xab30-0xab5a] | [0xab64-0xab65]
| [0xfb00-0xfb06] | [0xfb13-0xfb17] | [0xff41-0xff5a]
| [0x10428-0x1044f] | [0x118c0-0x118df] | [0x1d41a-0x1d433]
| [0x1d44e-0x1d454] | [0x1d456-0x1d467] | [0x1d482-0x1d49b]
| [0x1d4b6-0x1d4b9] | 0x1d4bb | [0x1d4bd-0x1d4c3]
| [0x1d4c5-0x1d4cf] | [0x1d4ea-0x1d503] | [0x1d51e-0x1d537]
| [0x1d552-0x1d56b] | [0x1d586-0x1d59f] | [0x1d5ba-0x1d5d3]
| [0x1d5ee-0x1d607] | [0x1d622-0x1d63b] | [0x1d656-0x1d66f]
| [0x1d68a-0x1d6a5] | [0x1d6c2-0x1d6da] | [0x1d6dc-0x1d6e1]
| [0x1d6fc-0x1d714] | [0x1d716-0x1d71b] | [0x1d736-0x1d74e]
| [0x1d750-0x1d755] | [0x1d770-0x1d788] | [0x1d78a-0x1d78f]
| [0x1d7aa-0x1d7c2] | [0x1d7c4-0x1d7c9] | 0x1d7cb

(* Letter, Titlecase *)

let regexp lt =
  0x1c5 | 0x1c8 | 0x1cb | 0x1f2 | [0x1f88-0x1f8f] | [0x1f98-0x1f9f]
| [0x1fa8-0x1faf] | 0x1fbc | 0x1fcc | 0x1ffc

(* Letter, Modifier *)

let regexp lm =
  [0x2b0-0x2c1] | [0x2c6-0x2d1] | [0x2e0-0x2e4] | 0x2ec | 0x2ee
| 0x374 | 0x37a | 0x559 | 0x640 | [0x6e5-0x6e6] | [0x7f4-0x7f5]
| 0x7fa | 0x81a | 0x824 | 0x828 | 0x971 | 0xe46 | 0xec6 | 0x10fc
| 0x17d7 | 0x1843 | 0x1aa7 | [0x1c78-0x1c7d] | [0x1d2c-0x1d6a]
| 0x1d78 | [0x1d9b-0x1dbf] | 0x2071 | 0x207f | [0x2090-0x209c]
| [0x2c7c-0x2c7d] | 0x2d6f | 0x2e2f | 0x3005 | [0x3031-0x3035]
| 0x303b | [0x309d-0x309e] | [0x30fc-0x30fe] | 0xa015
| [0xa4f8-0xa4fd] | 0xa60c | 0xa67f | [0xa69c-0xa69d]
| [0xa717-0xa71f] | 0xa770 | 0xa788 | [0xa7f8-0xa7f9] | 0xa9cf
| 0xa9e6 | 0xaa70 | 0xaadd | [0xaaf3-0xaaf4] | [0xab5c-0xab5f]
| 0xff70 | [0xff9e-0xff9f] | [0x16b40-0x16b43] | [0x16f93-0x16f9f]

(* Letter, Other *)

let regexp lo =
  0xaa | 0xba | 0x1bb | [0x1c0-0x1c3] | 0x294 | [0x5d0-0x5ea]
| [0x5f0-0x5f2] | [0x620-0x63f] | [0x641-0x64a] | [0x66e-0x66f]
| [0x671-0x6d3] | 0x6d5 | [0x6ee-0x6ef] | [0x6fa-0x6fc] | 0x6ff
| 0x710 | [0x712-0x72f] | [0x74d-0x7a5] | 0x7b1 | [0x7ca-0x7ea]
| [0x800-0x815] | [0x840-0x858] | [0x8a0-0x8b2] | [0x904-0x939]
| 0x93d | 0x950 | [0x958-0x961] | [0x972-0x980] | [0x985-0x98c]
| [0x98f-0x990] | [0x993-0x9a8] | [0x9aa-0x9b0] | 0x9b2
| [0x9b6-0x9b9] | 0x9bd | 0x9ce | [0x9dc-0x9dd] | [0x9df-0x9e1]
| [0x9f0-0x9f1] | [0xa05-0xa0a] | [0xa0f-0xa10] | [0xa13-0xa28]
| [0xa2a-0xa30] | [0xa32-0xa33] | [0xa35-0xa36] | [0xa38-0xa39]
| [0xa59-0xa5c] | 0xa5e | [0xa72-0xa74] | [0xa85-0xa8d]
| [0xa8f-0xa91] | [0xa93-0xaa8] | [0xaaa-0xab0] | [0xab2-0xab3]
| [0xab5-0xab9] | 0xabd | 0xad0 | [0xae0-0xae1] | [0xb05-0xb0c]
| [0xb0f-0xb10] | [0xb13-0xb28] | [0xb2a-0xb30] | [0xb32-0xb33]
| [0xb35-0xb39] | 0xb3d | [0xb5c-0xb5d] | [0xb5f-0xb61] | 0xb71
| 0xb83 | [0xb85-0xb8a] | [0xb8e-0xb90] | [0xb92-0xb95]
| [0xb99-0xb9a] | 0xb9c | [0xb9e-0xb9f] | [0xba3-0xba4]
| [0xba8-0xbaa] | [0xbae-0xbb9] | 0xbd0 | [0xc05-0xc0c]
| [0xc0e-0xc10] | [0xc12-0xc28] | [0xc2a-0xc39] | 0xc3d
| [0xc58-0xc59] | [0xc60-0xc61] | [0xc85-0xc8c] | [0xc8e-0xc90]
| [0xc92-0xca8] | [0xcaa-0xcb3] | [0xcb5-0xcb9] | 0xcbd | 0xcde
| [0xce0-0xce1] | [0xcf1-0xcf2] | [0xd05-0xd0c] | [0xd0e-0xd10]
| [0xd12-0xd3a] | 0xd3d | 0xd4e | [0xd60-0xd61] | [0xd7a-0xd7f]
| [0xd85-0xd96] | [0xd9a-0xdb1] | [0xdb3-0xdbb] | 0xdbd
| [0xdc0-0xdc6] | [0xe01-0xe30] | [0xe32-0xe33] | [0xe40-0xe45]
| [0xe81-0xe82] | 0xe84 | [0xe87-0xe88] | 0xe8a | 0xe8d
| [0xe94-0xe97] | [0xe99-0xe9f] | [0xea1-0xea3] | 0xea5 | 0xea7
| [0xeaa-0xeab] | [0xead-0xeb0] | [0xeb2-0xeb3] | 0xebd
| [0xec0-0xec4] | [0xedc-0xedf] | 0xf00 | [0xf40-0xf47]
| [0xf49-0xf6c] | [0xf88-0xf8c] | [0x1000-0x102a] | 0x103f
| [0x1050-0x1055] | [0x105a-0x105d] | 0x1061 | [0x1065-0x1066]
| [0x106e-0x1070] | [0x1075-0x1081] | 0x108e | [0x10d0-0x10fa]
| [0x10fd-0x1248] | [0x124a-0x124d] | [0x1250-0x1256] | 0x1258
| [0x125a-0x125d] | [0x1260-0x1288] | [0x128a-0x128d]
| [0x1290-0x12b0] | [0x12b2-0x12b5] | [0x12b8-0x12be] | 0x12c0
| [0x12c2-0x12c5] | [0x12c8-0x12d6] | [0x12d8-0x1310]
| [0x1312-0x1315] | [0x1318-0x135a] | [0x1380-0x138f]
| [0x13a0-0x13f4] | [0x1401-0x166c] | [0x166f-0x167f]
| [0x1681-0x169a] | [0x16a0-0x16ea] | [0x16f1-0x16f8]
| [0x1700-0x170c] | [0x170e-0x1711] | [0x1720-0x1731]
| [0x1740-0x1751] | [0x1760-0x176c] | [0x176e-0x1770]
| [0x1780-0x17b3] | 0x17dc | [0x1820-0x1842] | [0x1844-0x1877]
| [0x1880-0x18a8] | 0x18aa | [0x18b0-0x18f5] | [0x1900-0x191e]
| [0x1950-0x196d] | [0x1970-0x1974] | [0x1980-0x19ab]
| [0x19c1-0x19c7] | [0x1a00-0x1a16] | [0x1a20-0x1a54]
| [0x1b05-0x1b33] | [0x1b45-0x1b4b] | [0x1b83-0x1ba0]
| [0x1bae-0x1baf] | [0x1bba-0x1be5] | [0x1c00-0x1c23]
| [0x1c4d-0x1c4f] | [0x1c5a-0x1c77] | [0x1ce9-0x1cec]
| [0x1cee-0x1cf1] | [0x1cf5-0x1cf6] | [0x2135-0x2138]
| [0x2d30-0x2d67] | [0x2d80-0x2d96] | [0x2da0-0x2da6]
| [0x2da8-0x2dae] | [0x2db0-0x2db6] | [0x2db8-0x2dbe]
| [0x2dc0-0x2dc6] | [0x2dc8-0x2dce] | [0x2dd0-0x2dd6]
| [0x2dd8-0x2dde] | 0x3006 | 0x303c | [0x3041-0x3096] | 0x309f
| [0x30a1-0x30fa] | 0x30ff | [0x3105-0x312d] | [0x3131-0x318e]
| [0x31a0-0x31ba] | [0x31f0-0x31ff] | 0x3400 | 0x4db5 | 0x4e00
| 0x9fcc | [0xa000-0xa014] | [0xa016-0xa48c] | [0xa4d0-0xa4f7]
| [0xa500-0xa60b] | [0xa610-0xa61f] | [0xa62a-0xa62b]
| 0xa66e | [0xa6a0-0xa6e5] | 0xa7f7 | [0xa7fb-0xa801]
| [0xa803-0xa805] | [0xa807-0xa80a] | [0xa80c-0xa822]
| [0xa840-0xa873] | [0xa882-0xa8b3] | [0xa8f2-0xa8f7] | 0xa8f
| [0xa90a-0xa925] | [0xa930-0xa946] | [0xa960-0xa97c]
| [0xa984-0xa9b2] | [0xa9e0-0xa9e4] | [0xa9e7-0xa9ef]
| [0xa9fa-0xa9fe] | [0xaa00-0xaa28] | [0xaa40-0xaa42]
| [0xaa44-0xaa4b] | [0xaa60-0xaa6f] | [0xaa71-0xaa76]
| 0xaa7a | [0xaa7e-0xaaaf] | 0xaab1 | [0xaab5-0xaab6]
| [0xaab9-0xaabd] | 0xaac0 | 0xaac2 | [0xaadb-0xaadc]
| [0xaae0-0xaaea] | 0xaaf2 | [0xab01-0xab06] | [0xab09-0xab0e]
| [0xab11-0xab16] | [0xab20-0xab26] | [0xab28-0xab2e]
| [0xabc0-0xabe2] | 0xac00 | 0xd7a3 | [0xd7b0-0xd7c6]
| [0xd7cb-0xd7fb] | [0xf900-0xfa6d] | [0xfa70-0xfad9] | 0xfb1d
| [0xfb1f-0xfb28] | [0xfb2a-0xfb36] | [0xfb38-0xfb3c] | 0xfb3e
| [0xfb40-0xfb41] | [0xfb43-0xfb44] | [0xfb46-0xfbb1]
| [0xfbd3-0xfd3d] | [0xfd50-0xfd8f] | [0xfd92-0xfdc7]
| [0xfdf0-0xfdfb] | [0xfe70-0xfe74] | [0xfe76-0xfefc]
| [0xff66-0xff6f] | [0xff71-0xff9d] | [0xffa0-0xffbe]
| [0xffc2-0xffc7] | [0xffca-0xffcf] | [0xffd2-0xffd7]
| [0xffda-0xffdc] | [0x10000-0x1000b] | [0x1000d-0x10026]
| [0x10028-0x1003a] | [0x1003c-0x1003d] | [0x1003f-0x1004d]
| [0x10050-0x1005d] | [0x10080-0x100fa] | [0x10280-0x1029c]
| [0x102a0-0x102d0] | [0x10300-0x1031f] | [0x10330-0x10340]
| [0x10342-0x10349] | [0x10350-0x10375] | [0x10380-0x1039d]
| [0x103a0-0x103c3] | [0x103c8-0x103cf] | [0x10450-0x1049d]
| [0x10500-0x10527] | [0x10530-0x10563] | [0x10600-0x10736]
| [0x10740-0x10755] | [0x10760-0x10767] | [0x10800-0x10805]
| 0x10808 | [0x1080a-0x10835] | [0x10837-0x10838] | 0x1083c
| [0x1083f-0x10855] | [0x10860-0x10876] | [0x10880-0x1089e]
| [0x10900-0x10915] | [0x10920-0x10939] | [0x10980-0x109b7]
| [0x109be-0x109bf] | 0x10a00 | [0x10a10-0x10a13]
| [0x10a15-0x10a17] | [0x10a19-0x10a33] | [0x10a60-0x10a7c]
| [0x10a80-0x10a9c] | [0x10ac0-0x10ac7] | [0x10ac9-0x10ae4]
| [0x10b00-0x10b35] | [0x10b40-0x10b55] | [0x10b60-0x10b72]
| [0x10b80-0x10b91] | [0x10c00-0x10c48] | [0x11003-0x11037]
| [0x11083-0x110af] | [0x110d0-0x110e8] | [0x11103-0x11126]
| [0x11150-0x11172] | 0x11176 | [0x11183-0x111b2]
| [0x111c1-0x111c4] | 0x111da | [0x11200-0x11211]
| [0x11213-0x1122b] | [0x112b0-0x112de] | [0x11305-0x1130c]
| [0x1130f-0x11310] | [0x11313-0x11328] | [0x1132a-0x11330]
| [0x11332-0x11333] | [0x11335-0x11339] | 0x1133d
| [0x1135d-0x11361] | [0x11480-0x114af] | [0x114c4-0x114c5]
| 0x114c7 | [0x11580-0x115ae] | [0x11600-0x1162f] | 0x11644
| [0x11680-0x116aa] | 0x118ff | [0x11ac0-0x11af8]
| [0x12000-0x12398] | [0x13000-0x1342e] | [0x16800-0x16a38]
| [0x16a40-0x16a5e] | [0x16ad0-0x16aed] | [0x16b00-0x16b2f]
| [0x16b63-0x16b77] | [0x16b7d-0x16b8f] | [0x16f00-0x16f44]
| 0x16f50 | [0x1b000-0x1b001] | [0x1bc00-0x1bc6a]
| [0x1bc70-0x1bc7c] | [0x1bc80-0x1bc88] | [0x1bc90-0x1bc99]
| [0x1e800-0x1e8c4] | [0x1ee00-0x1ee03] | [0x1ee05-0x1ee1f]
| [0x1ee21-0x1ee22] | 0x1ee24 | 0x1ee27 | [0x1ee29-0x1ee32]
| [0x1ee34-0x1ee37] | 0x1ee39 | 0x1ee3b | 0x1ee42 | 0x1ee47
| 0x1ee49 | 0x1ee4b | [0x1ee4d-0x1ee4f] | [0x1ee51-0x1ee52]
| 0x1ee54 | 0x1ee57 | 0x1ee59 | 0x1ee5b | 0x1ee5d | 0x1ee5f
| [0x1ee61-0x1ee62] | 0x1ee64 | [0x1ee67-0x1ee6a]
| [0x1ee6c-0x1ee72] | [0x1ee74-0x1ee77] | [0x1ee79-0x1ee7c]
| 0x1ee7e | [0x1ee80-0x1ee89] | [0x1ee8b-0x1ee9b]
| [0x1eea1-0x1eea3] | [0x1eea5-0x1eea9] | [0x1eeab-0x1eebb]
| 0x20000 | 0x2a6d6 | 0x2a700 | 0x2b734 | 0x2b740 | 0x2b81d
| [0x2f800-0x2fa1d]

(* Number, Letter *)

let regexp nl =
  [0x16ee-0x16f0] | [0x2160-0x2182] | [0x2185-0x2188] | 0x3007
| [0x3021-0x3029] | [0x3038-0x303a] | [0xa6e6-0xa6ef]
| [0x10140-0x10174] | 0x10341 | 0x1034a | [0x103d1-0x103d5]
| [0x12400-0x1246e]

(* Mark, Nonspacing *)

let regexp mn =
  [0x300-0x36f] | [0x483-0x487] | [0x591-0x5bd] | 0x5bf
| [0x5c1-0x5c2] | [0x5c4-0x5c5] | 0x5c7 | [0x610-0x61a]
| [0x64b-0x65f] | 0x670 | [0x6d6-0x6dc] | [0x6df-0x6e4]
| [0x6e7-0x6e8] | [0x6ea-0x6ed] | 0x711 | [0x730-0x74a]
| [0x7a6-0x7b0] | [0x7eb-0x7f3] | [0x816-0x819] | [0x81b-0x823]
| [0x825-0x827] | [0x829-0x82d] | [0x859-0x85b] | [0x8e4-0x902]
| 0x93a | 0x93c | [0x941-0x948] | 0x94d | [0x951-0x957]
| [0x962-0x963] | 0x981 | 0x9bc | [0x9c1-0x9c4] | 0x9cd
| [0x9e2-0x9e3] | [0xa01-0xa02] | 0xa3c | [0xa41-0xa42]
| [0xa47-0xa48] | [0xa4b-0xa4d] | 0xa51 | [0xa70-0xa71] | 0xa75
| [0xa81-0xa82] | 0xabc | [0xac1-0xac5] | [0xac7-0xac8] | 0xacd
| [0xae2-0xae3] | 0xb01 | 0xb3c | 0xb3f | [0xb41-0xb44] | 0xb4d
| 0xb56 | [0xb62-0xb63] | 0xb82 | 0xbc0 | 0xbcd | 0xc00
| [0xc3e-0xc40] | [0xc46-0xc48] | [0xc4a-0xc4d] | [0xc55-0xc56]
| [0xc62-0xc63] | 0xc81 | 0xcbc | 0xcbf | 0xcc6 | [0xccc-0xccd]
| [0xce2-0xce3] | 0xd01 | [0xd41-0xd44] | 0xd4d | [0xd62-0xd63]
| 0xdca | [0xdd2-0xdd4] | 0xdd6 | 0xe31 | [0xe34-0xe3a]
| [0xe47-0xe4e] | 0xeb1 | [0xeb4-0xeb9] | [0xebb-0xebc]
| [0xec8-0xecd] | [0xf18-0xf19] | 0xf35 | 0xf37 | 0xf39
| [0xf71-0xf7e] | [0xf80-0xf84] | [0xf86-0xf87] | [0xf8d-0xf97]
| [0xf99-0xfbc] | 0xfc6 | [0x102d-0x1030] | [0x1032-0x1037]
| [0x1039-0x103a] | [0x103d-0x103e] | [0x1058-0x1059]
| [0x105e-0x1060] | [0x1071-0x1074] | 0x1082 | [0x1085-0x1086]
| 0x108d | 0x109d | [0x135d-0x135f] | [0x1712-0x1714]
| [0x1732-0x1734] | [0x1752-0x1753] | [0x1772-0x1773]
| [0x17b4-0x17b5] | [0x17b7-0x17bd] | 0x17c6 | [0x17c9-0x17d3]
| 0x17dd | [0x180b-0x180d] | 0x18a9 | [0x1920-0x1922]
| [0x1927-0x1928] | 0x1932 | [0x1939-0x193b] | [0x1a17-0x1a18]
| 0x1a1b | 0x1a56 | [0x1a58-0x1a5e] | 0x1a60 | 0x1a62
| [0x1a65-0x1a6c] | [0x1a73-0x1a7c] | 0x1a7f | [0x1ab0-0x1abd]
| [0x1b00-0x1b03] | 0x1b34 | [0x1b36-0x1b3a] | 0x1b3c | 0x1b42
| [0x1b6b-0x1b73] | [0x1b80-0x1b81] | [0x1ba2-0x1ba5]
| [0x1ba8-0x1ba9] | [0x1bab-0x1bad] | 0x1be6 | [0x1be8-0x1be9]
| 0x1bed | [0x1bef-0x1bf1] | [0x1c2c-0x1c33] | [0x1c36-0x1c37]
| [0x1cd0-0x1cd2] | [0x1cd4-0x1ce0] | [0x1ce2-0x1ce8] | 0x1ced
| 0x1cf4 | [0x1cf8-0x1cf9] | [0x1dc0-0x1df5] | [0x1dfc-0x1dff]
| [0x20d0-0x20dc] | 0x20e1 | [0x20e5-0x20f0] | [0x2cef-0x2cf1]
| 0x2d7f | [0x2de0-0x2dff] | [0x302a-0x302d] | [0x3099-0x309a]
| 0xa66f | [0xa674-0xa67d] | 0xa69f | [0xa6f0-0xa6f1] | 0xa802
| 0xa806 | 0xa80b | [0xa825-0xa826] | 0xa8c4 | [0xa8e0-0xa8f1]
| [0xa926-0xa92d] | [0xa947-0xa951] | [0xa980-0xa982] | 0xa9b3
| [0xa9b6-0xa9b9] | 0xa9bc | 0xa9e5 | [0xaa29-0xaa2e]
| [0xaa31-0xaa32] | [0xaa35-0xaa36] | 0xaa43 | 0xaa4c | 0xaa7c
| 0xaab0 | [0xaab2-0xaab4] | [0xaab7-0xaab8] | [0xaabe-0xaabf]
| 0xaac1 | [0xaaec-0xaaed] | 0xaaf6 | 0xabe5 | 0xabe8 | 0xabed
| 0xfb1e | [0xfe00-0xfe0f] | [0xfe20-0xfe2d] | 0x101fd | 0x102e0
| [0x10376-0x1037a] | [0x10a01-0x10a03] | [0x10a05-0x10a06]
| [0x10a0c-0x10a0f] | [0x10a38-0x10a3a] | 0x10a3f
| [0x10ae5-0x10ae6] | 0x11001 | [0x11038-0x11046]
| [0x1107f-0x11081] | [0x110b3-0x110b6] | [0x110b9-0x110ba]
| [0x11100-0x11102] | [0x11127-0x1112b] | [0x1112d-0x11134]
| 0x11173 | [0x11180-0x11181] | [0x111b6-0x111be]
| [0x1122f-0x11231] | 0x11234 | [0x11236-0x11237] | 0x112df
| [0x112e3-0x112ea] | 0x11301 | 0x1133c | 0x11340
| [0x11366-0x1136c] | [0x11370-0x11374] | [0x114b3-0x114b8]
| 0x114ba | [0x114bf-0x114c0] | [0x114c2-0x114c3]
| [0x115b2-0x115b5] | [0x115bc-0x115bd] | [0x115bf-0x115c0]
| [0x11633-0x1163a] | 0x1163d | [0x1163f-0x11640] | 0x116ab
| 0x116ad | [0x116b0-0x116b5] | 0x116b7 | [0x16af0-0x16af4]
| [0x16b30-0x16b36] | [0x16f8f-0x16f92] | [0x1bc9d-0x1bc9e]
| [0x1d167-0x1d169] | [0x1d17b-0x1d182] | [0x1d185-0x1d18b]
| [0x1d1aa-0x1d1ad] | [0x1d242-0x1d244] | [0x1e8d0-0x1e8d6]
| [0xe0100-0xe01ef]

(* Mark, Spacing Combining *)

let regexp mc =
  0x903 | 0x93b | [0x93e-0x940] | [0x949-0x94c] | [0x94e-0x94f]
| [0x982-0x983] | [0x9be-0x9c0] | [0x9c7-0x9c8] | [0x9cb-0x9cc]
| 0x9d7 | 0xa03 | [0xa3e-0xa40] | 0xa83 | [0xabe-0xac0] | 0xac9
| [0xacb-0xacc] | [0xb02-0xb03] | 0xb3e | 0xb40 | [0xb47-0xb48]
| [0xb4b-0xb4c] | 0xb57 | [0xbbe-0xbbf] | [0xbc1-0xbc2]
| [0xbc6-0xbc8] | [0xbca-0xbcc] | 0xbd7 | [0xc01-0xc03]
| [0xc41-0xc44] | [0xc82-0xc83] | 0xcbe | [0xcc0-0xcc4]
| [0xcc7-0xcc8] | [0xcca-0xccb] | [0xcd5-0xcd6] | [0xd02-0xd03]
| [0xd3e-0xd40] | [0xd46-0xd48] | [0xd4a-0xd4c] | 0xd57
| [0xd82-0xd83] | [0xdcf-0xdd1] | [0xdd8-0xddf] | [0xdf2-0xdf3]
| [0xf3e-0xf3f] | 0xf7f | [0x102b-0x102c] | 0x1031 | 0x1038
| [0x103b-0x103c] | [0x1056-0x1057] | [0x1062-0x1064]
| [0x1067-0x106d] | [0x1083-0x1084] | [0x1087-0x108c] | 0x108f
| [0x109a-0x109c] | 0x17b6 | [0x17be-0x17c5] | [0x17c7-0x17c8]
| [0x1923-0x1926] | [0x1929-0x192b] | [0x1930-0x1931]
| [0x1933-0x1938] | [0x19b0-0x19c0] | [0x19c8-0x19c9]
| [0x1a19-0x1a1a] | 0x1a55 | 0x1a57 | 0x1a61 | [0x1a63-0x1a64]
| [0x1a6d-0x1a72] | 0x1b04 | 0x1b35 | 0x1b3b | [0x1b3d-0x1b41]
| [0x1b43-0x1b44] | 0x1b82 | 0x1ba1 | [0x1ba6-0x1ba7] | 0x1baa
| 0x1be7 | [0x1bea-0x1bec] | 0x1bee | [0x1bf2-0x1bf3]
| [0x1c24-0x1c2b] | [0x1c34-0x1c35] | 0x1ce1 | [0x1cf2-0x1cf3]
| [0x302e-0x302f] | [0xa823-0xa824] | 0xa827 | [0xa880-0xa881]
| [0xa8b4-0xa8c3] | [0xa952-0xa953] | 0xa983 | [0xa9b4-0xa9b5]
| [0xa9ba-0xa9bb] | [0xa9bd-0xa9c0] | [0xaa2f-0xaa30]
| [0xaa33-0xaa34] | 0xaa4d | 0xaa7b | 0xaa7d | 0xaaeb
| [0xaaee-0xaaef] | 0xaaf5 | [0xabe3-0xabe4] | [0xabe6-0xabe7]
| [0xabe9-0xabea] | 0xabec | 0x11000 | 0x11002 | 0x11082
| [0x110b0-0x110b2] | [0x110b7-0x110b8] | 0x1112c | 0x11182
| [0x111b3-0x111b5] | [0x111bf-0x111c0] | [0x1122c-0x1122e]
| [0x11232-0x11233] | 0x11235 | [0x112e0-0x112e2]
| [0x11302-0x11303] | [0x1133e-0x1133f] | [0x11341-0x11344]
| [0x11347-0x11348] | [0x1134b-0x1134d] | 0x11357
| [0x11362-0x11363] | [0x114b0-0x114b2] | 0x114b9
| [0x114bb-0x114be] | 0x114c1 | [0x115af-0x115b1]
| [0x115b8-0x115bb] | 0x115be | [0x11630-0x11632]
| [0x1163b-0x1163c] | 0x1163e | 0x116ac | [0x116ae-0x116af]
| 0x116b6 | [0x16f51-0x16f7e] | [0x1d165-0x1d166]
| [0x1d16d-0x1d172]

(* Punctuation, Connection *)

let regexp pc =
  0x5f | [0x203f-0x2040] | 0x2054 | [0xfe33-0xfe34]
| [0xfe4d-0xfe4f] | 0xff3f

(* Other, Format *)

let regexp cf =
  0xad | [0x600-0x605] | 0x61c | 0x6dd | 0x70f | 0x180e
| [0x200b-0x200f] | [0x202a-0x202e] | [0x2060-0x2064]
| [0x2066-0x206f] | 0xfeff | [0xfff9-0xfffb] | 0x110bd
| [0x1bca0-0x1bca3] | [0x1d173-0x1d17a] | 0xe0001
| [0xe0020-0xe007f]

(* Decimal digit character *)

let regexp decimal_digit_char = nd (* | nd_esc *)

(* Combining character *)

let regexp combining_char = mn | mc (* | mn_esc | mc_esc *)

(* Connecting character *)

let regexp connecting_char = pc (* | pc_esc *)

(* Formatting character *)

let regexp formatting_char = cf (* | cf_esc *)

(* Letter character *)

let regexp letter_char = lu | ll | lt | lm | lo | nl
(* | lu_esc | ll_esc | lt_esc | lm_esc | lo_esc | nl_esc *)

(* Identifier *)

let regexp start_char = letter_char | '_'

let regexp part_char =
  letter_char        (* letter-character   *)
| decimal_digit_char (* decimal-digit-char *)
| connecting_char    (* connecting-char    *)
| combining_char     (* combining-char     *)
| formatting_char    (* formatting-char    *)

let regexp ident = start_char part_char*

(* Real *)

let regexp decimal = decimal_digit+
let regexp exponent = ['e' 'E'] ['+' '-']? decimal
let regexp real_type_suffix = ['F' 'f' 'D' 'd' 'M' 'm']
let regexp real = (decimal? '.')? decimal exponent? real_type_suffix?

(* Characters *)

let regexp single_char =
  [^ '"' '\\' '\n' '\r' "\r\n" 0x0085 0x2028 0x2029]
let regexp simple_esc =
  "\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n"
| "\\r"  | "\\t" | "\\v"
let regexp hex_esc = "\\x" hex_digit hex_digit? hex_digit? hex_digit?
let regexp four_hex = hex_digit hex_digit hex_digit hex_digit
let regexp uni_esc = "\\u" four_hex | "\\U" four_hex four_hex
let regexp character = single_char | simple_esc | hex_esc | uni_esc
let regexp char = "'" character "'"

(* Rules *)

(* The rule [scan] scans the input buffer for directives, strings,
comments, blanks, new lines and end of file characters. As a result,
either the matched input is copied to [stdout] or not, depending on
the compilation directives. If not copied, new line characters are
output.

Scanning is triggered by the function call [scan env mode offset trace
lexbuf], where [env] is the set of defined symbols (introduced by
`#define'), [mode] specifies whether we are copying or skipping the
input, [offset] informs about the location in the line (either there
is a prefix of blanks, or at least a non-blank character has been
read), and [trace] is the stack of conditional directives read so far.

The first call is [scan Env.empty Copy (Prefix 0) []], meaning that we
start with an empty environment, that copying the input is enabled by
default, and that we are at the start of a line and no previous
conditional directives have been read yet.

When an "#if" is matched, the trace is extended by the call [extend
lexbuf (If mode) trace], during the evaluation of which the syntactic
validity of having encountered an "#if" is checked (for example, it
would be invalid had an "#elif" been last read). Note that the current
mode is stored in the trace with the current directive -- that mode
may be later restored (see below for some examples). Moreover, the
directive would be deemed invalid if its current position in the line
(that is, its offset) were not preceded by blanks or nothing,
otherwise the rule [expr] is called to scan the boolean expression
associated with the "#if": if it evaluates to [true], the result is
[Copy], meaning that we may copy what follows, otherwise skip it --
the actual decision depending on the current mode. That new mode is
used if we were in copy mode, and the offset is reset to the start of
a new line (as we read a new line in [expr]); otherwise we were in
skipping mode and the value of the conditional expression must be
ignored (but not its syntax), and we continue skipping the input.

When an "#else" is matched, the trace is extended with [Else], then,
if the directive is not at a wrong offset, the rest of the line is
scanned with [pp_newline]. If we were in copy mode, the new mode
toggles to skipping mode; otherwise, the trace is searched for the
last encountered "#if" of "#elif" and the associated mode is restored.

The case "#elif" is the result of the fusion (in the technical sense)
of the code for dealing with an "#else" followed by an "#if".

When an "#endif" is matched, the trace is reduced, that is, all
conditional directives are popped until an [If mode'] is found and
[mode'] is restored as the current mode.

Consider the following four cases, where the modes (Copy/Skip) are
located between the lines:

                 Copy ----+                          Copy ----+
#if true                  |       #if true                    |
                 Copy     |                          Copy     |
#else                     |       #else                       |
             +-- Skip --+ |                      +-- Skip --+ |
  #if true   |          | |         #if false    |          | |
             |   Skip   | |                      |   Skip   | |
  #else      |          | |         #else        |          | |
             +-> Skip   | |                      +-> Skip   | |
  #endif                | |         #endif                  | |
                 Skip <-+ |                          Skip <-+ |
#endif                    |       #endif                      |
                 Copy <---+                          Copy <---+


             +-- Copy ----+                          Copy --+-+
#if false    |            |       #if false                 | |
             |   Skip     |                          Skip   | |
#else        |            |       #else                     | |
             +-> Copy --+ |                    +-+-- Copy <-+ | 
  #if true              | |         #if false  | |            |
                 Copy   | |                    | |   Skip     |
  #else                 | |         #else      | |            |
                 Skip   | |                    | +-> Copy     |
  #endif                | |         #endif     |              |
                 Copy <-+ |                    +---> Copy     |
#endif                    |       #endif                      |
                 Copy <---+                          Copy <---+

The following four cases feature #elif. Note that we put between
brackets the mode saved for the #elif, which is sometimes restored
later.

                 Copy --+                            Copy --+
#if true                |         #if true                  |
                 Copy   |                            Copy   |
#elif true   +--[Skip]  |         #elif false    +--[Skip]  |
             |   Skip   |                        |   Skip   |
#else        |          |         #else          |          |
             +-> Skip   |                        +-> Skip   |
#endif                  |         #endif                    |
                 Copy <-+                            Copy <-+


             +-- Copy --+-+                      +-- Copy ----+
#if false    |          | |       #if false      |            |
             |   Skip   | |                      |   Skip     |
#elif true   +->[Copy]  | |       #elif false    +->[Copy]--+ |
                 Copy <-+ |                          Skip   | |
#else                     |       #else                     | |
                 Skip     |                          Copy <-+ |
#endif                    |       #endif                      |
                 Copy <---+                          Copy <---+

Note how "#elif" indeed behaves like an "#else" followed by an "#if",
and the mode stored with the data constructor [Elif] corresponds to
the mode before the virtual "#if".

Important note: Comments and strings are recognised as such only in
copy mode, which is a different behaviour from the preprocessor of GNU
GCC, which always does. *)

let rec scan env mode offset trace = lexer
     newline -> copy lexbuf; handle_nl lexbuf;
                scan env mode (Prefix 0) trace lexbuf
|      blank -> (match offset with
                   Prefix n -> scan env mode (Prefix (n+1)) trace lexbuf
                 |   Inline -> copy lexbuf;
                               scan env mode Inline trace lexbuf)
| '#' blank* -> let prelude = Ulexing.utf8_lexeme lexbuf
                in directive prelude lexbuf
|        eof -> (match trace with
                   [] -> expand offset; flush stdout; (env, trace) 
                 |  _ -> fail "Missing #endif." lexbuf)
|        '"' -> if mode = Copy then begin
                   expand offset; copy lexbuf;
                   handle_err in_norm_str lexbuf
                end;
                scan env mode Inline trace lexbuf
|      "@\"" -> if mode = Copy then begin
                   expand offset; copy lexbuf;
                   handle_err in_verb_str lexbuf
                end;
                scan env mode Inline trace lexbuf
|       "//" -> if mode = Copy then begin
                   expand offset; copy lexbuf;
                   in_line_com mode lexbuf
                end;
                scan env mode Inline trace lexbuf
|       "/*" -> if mode = Copy then begin
                   expand offset; copy lexbuf;
                   handle_err in_block_com lexbuf
                end;
                scan env mode Inline trace lexbuf
|          _ -> if mode = Copy then (expand offset; copy lexbuf);
                scan env mode Inline trace lexbuf

(* Directives *)

and directive prelude = lexer
  ident ->
    let id = Ulexing.utf8_lexeme lexbuf
    in if not (List.mem id directives)
       then fail "Invalid preprocessing directive." lexbuf
       else if offset = Inline
            then fail "Directive invalid inside line." lexbuf
            else let seg = Error.mk_seg lexbuf in 
       (match id with
         "if" ->
          let mode' = expr env lexbuf in
          let new_mode = if mode = Copy then mode' else Skip in
          let trace' = extend seg (If mode) trace
          in scan env new_mode (Prefix 0) trace' lexbuf
       | "else" ->
          let () = pp_newline lexbuf in
          let new_mode =
            if mode = Copy then Skip else last_mode trace in
          let trace' = extend seg Else trace
          in scan env new_mode (Prefix 0) trace' lexbuf
       | "elif" ->
          let mode' = expr env lexbuf in
          let trace', new_mode =
            match mode with
              Copy -> extend seg (Elif Skip) trace, Skip
            | Skip -> let old_mode = last_mode trace
                      in extend seg (Elif old_mode) trace,
                         if old_mode = Copy then mode' else Skip
          in scan env new_mode (Prefix 0) trace' lexbuf
       | "endif" ->
          let () = pp_newline lexbuf in
          let trace', new_mode = reduce_cond seg trace
          in scan env new_mode (Prefix 0) trace' lexbuf
       | "define" ->
          let id, seg = identifier env lexbuf
          in if id="true" || id="false"
             then let msg = "Symbol \"" ^ id ^ "\" cannot be defined."
                  in stop msg seg
             else if Env.mem id env
                  then let msg = "Symbol \"" ^ id
                                 ^ "\" was already defined."
                       in stop msg seg
                  else scan (Env.add id env) mode (Prefix 0) trace lexbuf
       | "undef" ->
           let id, _ = identifier env lexbuf
           in scan (Env.remove id env) mode (Prefix 0) trace lexbuf
       | "error" ->
           stop (message [] lexbuf) seg
       | "warning" ->
           let start_p, end_p = seg in
           let msg = message [] lexbuf
           in prerr_endline 
                ("Warning at line " ^ string_of_int start_p.pos_lnum 
              ^ ", char "
              ^ string_of_int (start_p.pos_cnum - start_p.pos_bol)
              ^ "--" ^ string_of_int (end_p.pos_cnum - end_p.pos_bol)
              ^ ":\n" ^ msg);
            scan env mode (Prefix 0) trace lexbuf
       | "region" ->
           let msg = message [] lexbuf
           in expand offset;
              print_endline (prelude ^ "region" ^ msg);
              scan env mode (Prefix 0) (Region::trace) lexbuf
       | "endregion" ->
           let msg = message [] lexbuf
           in expand offset;
              print_endline (prelude ^ "endregion" ^ msg);
              scan env mode (Prefix 0) (reduce_reg seg trace) lexbuf
       | "line" ->
           expand offset;
           print_string (prelude ^ "line");
           line_ind lexbuf;
           scan env mode (Prefix 0) trace lexbuf
       | s -> assert false 
       )
| _ -> fail "Directive expected." lexbuf

(* Support for #define and #undef *)

and identifier env = lexer
  blank* -> let r = __identifier env lexbuf
            in pp_newline lexbuf; r

and __identifier env = lexer
  ident -> let id = Ulexing.utf8_lexeme lexbuf
           in id, Error.mk_seg lexbuf

(* Line indicator (#line) *)

and line_ind = lexer
  blank* -> let space = Ulexing.utf8_lexeme lexbuf
            in print_string space; line_indicator lexbuf

and line_indicator = lexer
  decimal -> let ind = Ulexing.utf8_lexeme lexbuf
             in print_string ind; end_indicator lexbuf
| ident -> let id = Ulexing.utf8_lexeme lexbuf
           in (match id with
                 "default" | "hidden" ->
                   print_endline (id ^ message [] lexbuf)
               | _ -> fail "Invalid line indicator." lexbuf)
| newline | eof -> fail "Line indicator expected." lexbuf

and end_indicator = lexer
  blank* newline -> copy lexbuf; handle_nl lexbuf
| blank* eof     -> copy lexbuf
| blank* "//"    -> copy lexbuf; print_endline (message [] lexbuf)
| blank+ '"'     -> copy lexbuf;
                    handle_err in_norm_str lexbuf;
                    opt_line_com lexbuf
| _              -> fail "Line comment or blank expected." lexbuf

and opt_line_com = lexer
  newline -> copy lexbuf; handle_nl lexbuf
| eof     -> copy lexbuf
| blank+  -> copy lexbuf; opt_line_com lexbuf
| "//"    -> print_endline ("//" ^ message [] lexbuf)

(* New lines and verbatim sequence of characters *)

and pp_newline = lexer
  newline -> copy lexbuf; handle_nl lexbuf
| blank+  -> pp_newline lexbuf
| "//"    -> in_line_com Skip lexbuf
| _       -> fail "Only a single-line comment allowed." lexbuf

and message acc = lexer
  newline -> handle_nl buffer;
             mk_str (List.length acc) acc
|     eof -> mk_str (List.length acc) acc
|       _ -> let c = Ulexing.utf8_lexeme lexbuf
             in message (c::acc) lexbuf

(* Comments *)

and in_line_com mode = lexer
  newline -> copy lexbuf; handle_nl lexbuf
|     eof -> flush stdout
|       _ -> if mode = Copy then copy lexbuf;
                                 in_line_com mode lexbuf

and in_block_com = lexer
  newline -> copy lexbuf; handle_nl lexbuf; in_block_com lexbuf
|    "*/" -> copy lexbuf
|     eof -> raise (Local_err "Unterminated comment.")
|       _ -> copy lexbuf; in_block_com lexbuf

(* Strings *)

and in_norm_str = lexer
   "\\\"" -> copy lexbuf; in_norm_str lexbuf
|     '"' -> copy lexbuf
| newline -> fail "Newline invalid in string." lexbuf
|     eof -> raise (Local_err "Unterminated string.")
|       _ -> copy lexbuf; in_norm_str lexbuf

and in_verb_str = lexer
   "\"\"" -> copy lexbuf; in_verb_str lexbuf
|     '"' -> copy lexbuf
| newline -> copy lexbuf; handle_nl lexbuf; in_verb_str lexbuf
|     eof -> raise (Local_err "Unterminated string.")
|       _ -> copy lexbuf; in_verb_str lexbuf

(* Internal definitions *)

let lex buffer =
  let _env, trace = scan Env.empty Copy (Prefix 0) [] buffer
in assert (trace = [])

(* Exported definitions *)

type filename = string

let trace ~(input: filename) : unit =
  match open_in input with
    cin ->
      lex_curr_p := Lexing.{ !lex_curr_p with pos_fname = input };
      let buffer = Ulexing.from_utf8_channel cin in
        let open Error
      in (try lex buffer with
            Lexer diag    -> print "lexical" diag
          | Parser diag   -> print "syntactical" diag
          | Eparser.Error -> print "" ("Parse", mk_seg buffer));
         close_in cin; flush stdout
  | exception Sys_error msg -> prerr_endline msg
